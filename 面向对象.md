#### 抽象
> 解释
* 如果一个东西需要量产（复用），那么我们为这个东西创建一个模具，后期我们会通过这个模具来批量的进行生产，我们需要分析这个东西特点，根据这个特点来创建这个模具，或者根据要生产的内容创建流水线，需要对这些要批量创建的内容进行共同特征的提取，我们把这个提取事物共同特征的过程称为：抽象 - 抽出像的部分
> 特点
* 共同（相似）特性
* 不具体的
> 类/类型
* 我们把抽象后的生产线称为：类，类型
---

## 面向对象的三大特征
#### 1、封装
> 是什么
* 根据抽象进行流水线作业的搭建，我们把这个过程称为封装
    - 对内进行封装，隐藏细节，对外提供接口
> 对象
* 我们把通过生成线生成出来的产品称为：对象
#### 2、继承
> 是什么
* 根据一个已有的生产线可以扩展出来一个新的生产线（根据小车的生产线扩展出SUV的生产线），这个时候没有必要重头到尾的去创建一个新的生产线，只需要把原来的小车生产线修改一下就可以变成新的SUV的生成线了，这个过程我们称为：继承
> 什么情况下用（多态）
#### 3、多态
> 是什么
*  一种类型的事物，如果拥有多个不同的子类型，那么针对这个类型来说的话，我们可以说同一个主类型具有不同的功能
* 同样是车，车又有小车，还有卡车，小车可以装人，卡车可以装货，我们可以说车这中类型具有不同的状态，那么我们把这种现象称为：==多态==。

---
#### 面向对象
> 面向对象编程其实就是自定义数据类型

> 类与对象
- 类是对一类具有相同特征的事物的抽象化描述
- 对象是类的实例化（具体化）
>  面向对象 & 面向过程
*   面向过程关注的是：过程
*   面向对象关注的是：特征
*   面向对象不是没过过程，而是不关注过程

> 面向对象的编程实例

```
 1. 分析需求

    学员管理系统
    1. 学员信息 - 抽象：学员类型
    
    学员类型 - 抽象
    - 姓名
    - 性别
    - 年龄
    - 学习
    
    把一个对象的特征分成两大类型
    - 属性：对对象的描述，我们会用非函数的值描述属性
    - 方法：对象的动作，功能称为方法，用函数来实现功能
    
    2. 封装
       - 通过普通函数封装 : 封装过程
       - 通过类来封装 : 封装类型
           - class
    
    class 关键字
    es6新增的关键字，用来创建（封装）类型
    
    class 类名称 {
    //类型主体代码
    }
     类型的名称有一个约定：大驼峰命名，首字母也要大写
         - 小驼峰：普通函数
         - 大驼峰：构造函数，与类有关的一个函数
```
> ES6

```
 class Student {
            /*
            * 构造函数
            *   当一个类被new（实例化），就会默认调用该类下的一个方法：constructor，我们称这个函数为类的构造函数
            *   作用：
            *       初始化对象，因为构造函数在new的时候会自动调用，所有我们可以在这个函数对要产生的对象做一些初始化的工作
            *
            *   注意：
            *       类中的函数使用的es6的写法
            *   当我们实例化一个类的时候，该类的内部会自动创建一个与该类有关的对象，并把类中this关键字指向该对象，通过会把这个this返回出去
            * */
            constructor(username, age, gender) {
                console.log('初始化');
                // console.log(this);
                this.username = username;
                this.age = age;
                this.gender = gender;
            }

            /*
            * 给对象添加方法
            *   方法中this指向调用该方法的对象
            * */
            study() {
                console.log(this.username, '学习');
            }
        }

        /*
        * 类型创建出来是要使用的，根据类型得到具体的与该类型有关的对象
        * 类需要通过 new 关键字来调用才能产生对象，new 后面的是类中一个特殊的函数 - 构造函数
        * 注意：new 后面的 Student 不是类的名称，是类里面一个特殊的函数的名称
        * */
        var s1 = new Student('mt', 30, '男');  // var s = {}
        console.log(s1);
        s1.study();
```
>ES5

```
function Student(username, age, gender) {
            var obj = new Object();
            obj.username = username;
            obj.age = age;
            obj.gender = gender;
            obj.study = function() {
                console.log('学习');
            };
            return obj;
        }

        var mt = Student('莫涛','30','男');
        var zMouse = Student('钟毅','33','男');
        
 function Student(username, age, gender) {
            this.username = username;
            this.age = age;
            this.gender = gender;
            this.study = function() {
                console.log('学习');
            };
        }

        var mt = new Student('莫涛','30','男');
        var zMouse = new Student('钟毅','33','男');

        console.dir(mt);
```

> new
* 运算符，new的后面只能跟函数
    *  使用new也可以调用函数，不需要加括号调用，如果我们希望在调用函数的时候传入参数的时候，可以加括号
    * 当我们调用函数的时候，函数在执行的时候会创建一些的内置的数据-arguments
    * 当我们使用new的方式来调用的时候，除了上面的一些对象以外，函数还会在内部创建一个空对象，同时还会把这个函数的this指向该对象
    * 在函数执行完成以后，函数还会把这个自动的创建的对象作为函数的返回值进行返回
    *  当我们通过new来调用一个函数的时候，其实就是创建对象
* 注意
    * 当我们使用new的时候，js会保证这个函数的返回一定是一个对象，如果该函数有明确的return，那么会
        *  如果return的是非对象的值，那么返回默认创建的对象
        * 如果return的是一个对象，那么return的对象就是返回的对象
> 公有数据与私有数据
* 把对象私有的数据添加到对象自身上
* 为了能够让同一个类型的对象所拥有的公有值方便存储和查找，不影响其他的对象，所以js为我们提供了一个特殊位置来存放某个类所拥有的公有特性（==prototype==）
* 每一个函数会自动创建prototype，同时还会在prototype添加默认的属性constructor，值指向构造函数，这样的话，我们就可以通过对象来调用这个属性，获取该对象的构造函数了
##### prototype原型
> 当一个函数被创建的时候，函数下会自动添加一些属性，其中有一个属性：prototype，他的值是一个对象

> 当一个对象被创建的时候，对象也会有一些默认添加的属性，其中有一个属性：__proto__，他的值也是一个对象

> 对象的__proto__其实就是创建该对象的构造函数下的prototype

>  类似作用域链，对象属性或方法的查找或调用也有自己的规则，当我们去调用一个对象下的属性或方法的时候，首先会该对象自身上查找调用，如果没有，则会在该对象的__proto__下去查找调用
----
### 原型与原型链
> 原型
* prototype，对象是通过构造函数创建出来的，如果某个类型所对应的对象有一些共用的数据，那么为了节省内存空间，方便维护管理，js把这些对象所公用的内容存储在一个统一的位置，这类对象又可能很方便的去调用他。
* js把某个类型的对象所公用的数据保存在这类的构造函数下的一个指定属性下面，这个属性是构造函数的属性，名称是：prototype，他的值是一个对象，用来保存这类对象所有公有数据的
* 为了能够让对象找到公有数据，所在在对象创建的时候，会把prototype同时赋值给对象，这个属性是：__proto__，也就是：当一个对象被构造函数创建出来的时候，会自动添加一个属性__proto__，他指向构造函数的prototype，所以对象.__proto__就是这个对象的构造函数的.prototype，我们可以通过 对象.__proto__调用到构造函数的prototype
* 虽然我们可以通过__proto__调用到构造函数的prototype了，但是js觉得有点复杂了，所以把这个调用进行了简化，当我们去调用一个对象属性或者方法的时候，会按照一种规则进行查找，首先会在对象自身上进行查找，如果找不到，会自动去这个对象__proto__上去查找